#!/usr/bin/env bun
/**
 * Main build script for Haltija
 * Compiles TypeScript, bundles for browser/bun targets, syncs to desktop app
 */

import { $ } from 'bun'
import { writeFileSync, readFileSync } from 'fs'

// 0. Generate version.ts from package.json (single source of truth)
const pkg = JSON.parse(readFileSync('package.json', 'utf-8'))
writeFileSync('src/version.ts', `/**
 * Haltija - Browser Control for AI Agents
 * https://github.com/tonioloewald/haltija
 *
 * Copyright 2025 Tonio Loewald
 * SPDX-License-Identifier: Apache-2.0
 *
 * ⚠️  AUTO-GENERATED FROM package.json - DO NOT EDIT THIS FILE
 * ⚠️  To change the version, update package.json and run: bun run build
 */

export const VERSION = '${pkg.version}'
`)

// 1. Generate schema-derived files BEFORE embedding (they become embedded assets)
const { ALL_ENDPOINTS, getInputSchema } = await import('../src/api-schema')
const mcpEndpoints = ALL_ENDPOINTS
  .filter(ep => (ep as any).visibility !== 'internal')
  .map(ep => ({
    path: ep.path,
    method: ep.method,
    summary: ep.summary,
    description: ep.description,
    inputSchema: getInputSchema(ep),
  }))
writeFileSync('apps/mcp/src/endpoints.json', JSON.stringify(mcpEndpoints, null, 2))

// Generate CLI hints from schema (path -> hint)
const cliHints: Record<string, string> = {}
for (const ep of ALL_ENDPOINTS) {
  if ((ep as any).hints) {
    // Convert path to CLI subcommand name (e.g., /tree -> tree, /events/watch -> events-watch)
    const subcommand = ep.path.slice(1).replace(/\//g, '-')
    cliHints[subcommand] = (ep as any).hints
  }
}
writeFileSync('bin/hints.json', JSON.stringify(cliHints, null, 2))

// 6. Generate API.md from api-schema (single source of truth)
function generateApiMd(): string {
  const lines: string[] = [
    '# Haltija API Reference',
    '',
    '> **Auto-generated from `src/api-schema.ts`** - Do not edit directly.',
    '',
    '## Quick Start',
    '',
    '```bash',
    '# Is it working?',
    'curl localhost:8700/status',
    '',
    '# What tabs are connected?',
    'curl localhost:8700/windows',
    '',
    "# What's on the page?",
    'curl -X POST localhost:8700/tree -d \'{"mode":"actionable"}\'',
    '',
    '# Click something',
    'curl -X POST localhost:8700/click -d \'{"selector":"#submit"}\'',
    '```',
    '',
    '---',
    '',
  ]

  // Group endpoints by category - ordered by "what you need first"
  // Filter out internal endpoints (visibility: 'internal')
  const byCategory = new Map<string, typeof ALL_ENDPOINTS>()
  for (const ep of ALL_ENDPOINTS) {
    // Skip internal endpoints - they're not part of the public API
    if ((ep as any).visibility === 'internal') continue
    
    const cat = (ep as any).category || 'other'
    if (!byCategory.has(cat)) byCategory.set(cat, [])
    byCategory.get(cat)!.push(ep)
  }

  // Order by workflow: connect -> see -> do -> watch -> advanced
  const categoryOrder = ['meta', 'dom', 'interaction', 'navigation', 'events', 'mutations', 'selection', 'windows', 'recording', 'testing', 'debug', 'other']
  const categoryTitles: Record<string, string> = {
    meta: 'Connection & Status',
    dom: 'See the Page',
    interaction: 'Do Things',
    navigation: 'Navigate',
    events: 'Watch What Happens',
    mutations: 'Watch DOM Changes',
    selection: 'User Selection',
    windows: 'Multiple Tabs',
    recording: 'Record & Replay',
    testing: 'Run Tests',
    debug: 'Escape Hatches',
    other: 'Other',
  }

  for (const cat of categoryOrder) {
    const eps = byCategory.get(cat)
    if (!eps || eps.length === 0) continue

    lines.push(`## ${categoryTitles[cat] || cat}`)
    lines.push('')

    for (const ep of eps) {
      lines.push(`### \`${ep.method} ${ep.path}\``)
      lines.push('')
      lines.push(`**${ep.summary}**`)
      lines.push('')
      
      if (ep.description) {
        lines.push(ep.description)
        lines.push('')
      }

      const schema = getInputSchema(ep)
      if (schema && (schema as any).properties) {
        const props = (schema as any).properties
        const propNames = Object.keys(props)
        if (propNames.length > 0) {
          lines.push('**Parameters:**')
          lines.push('')
          lines.push('| Name | Type | Description |')
          lines.push('|------|------|-------------|')
          for (const name of propNames) {
            const prop = props[name]
            const type = prop.type || 'any'
            const desc = prop.description || ''
            const required = (schema as any).required?.includes(name) ? ' *(required)*' : ''
            lines.push(`| \`${name}\` | ${type} | ${desc}${required} |`)
          }
          lines.push('')
        }
      }

      // Add examples if present
      const examples = (ep as any).examples
      if (examples && examples.length > 0) {
        lines.push('**Examples:**')
        lines.push('')
        for (const ex of examples) {
          lines.push(`- **${ex.name}**: ${ex.description || ''}`)
          lines.push('  ```json')
          lines.push(`  ${JSON.stringify(ex.input)}`)
          lines.push('  ```')
          
          // Include response example if present
          if (ex.response) {
            lines.push('  Response:')
            lines.push('  ```json')
            lines.push(`  ${JSON.stringify(ex.response, null, 2).split('\n').join('\n  ')}`)
            lines.push('  ```')
          }
          
          // Include curl example if present
          if (ex.curl) {
            lines.push('  ```bash')
            lines.push(`  ${ex.curl}`)
            lines.push('  ```')
          }
        }
        lines.push('')
      }

      lines.push('---')
      lines.push('')
    }
  }

  return lines.join('\n')
}

writeFileSync('API.md', generateApiMd())

// 7. Generate DOCS.md - hj-centric quick start (single source of truth)
function generateDocsMd(): string {
  const lines: string[] = [
    '# Haltija: Browser Control for AI Agents',
    '',
    '> **Auto-generated from `src/api-schema.ts`** - Do not edit directly.',
    '',
    'You have access to a live browser tab. Use the `hj` command to see the DOM,',
    'click elements, type text, run JavaScript, and watch for changes.',
    '',
    '## Quick Start',
    '',
    '```',
    'hj status              # Check connection',
    'hj tree                # See page structure (ref IDs for targeting)',
    'hj click 42            # Click element by ref ID',
    'hj click "#submit"     # Click by CSS selector',
    'hj type 10 "hello"     # Type into input (realistic keystroke simulation)',
    'hj key Enter           # Press keys',
    'hj screenshot          # Capture page',
    'hj --help              # All commands',
    '```',
    '',
    '## Commands by Category',
    '',
  ]

  // Group endpoints by category
  const byCategory = new Map<string, typeof ALL_ENDPOINTS>()
  for (const ep of ALL_ENDPOINTS) {
    if ((ep as any).visibility === 'internal') continue
    const cat = (ep as any).category || 'other'
    if (!byCategory.has(cat)) byCategory.set(cat, [])
    byCategory.get(cat)!.push(ep)
  }

  const categoryOrder = ['meta', 'dom', 'interaction', 'navigation', 'events', 'mutations', 'selection', 'windows', 'recording', 'testing', 'debug']
  const categoryTitles: Record<string, string> = {
    meta: 'Status & Info',
    dom: 'See the Page',
    interaction: 'Interact',
    navigation: 'Navigate',
    events: 'Watch Events',
    mutations: 'Watch DOM Changes',
    selection: 'User Selection',
    windows: 'Multiple Tabs',
    recording: 'Record & Replay',
    testing: 'Run Tests',
    debug: 'Debug & Eval',
  }

  // Map REST paths to hj subcommands
  const pathToHj = (path: string, method: string): string => {
    // /mutations/watch -> mutations-watch, /test/run -> test-run
    const sub = path.slice(1).replace(/\//g, '-')
    return `hj ${sub}`
  }

  for (const cat of categoryOrder) {
    const eps = byCategory.get(cat)
    if (!eps || eps.length === 0) continue

    lines.push(`### ${categoryTitles[cat] || cat}`)
    lines.push('')

    for (const ep of eps) {
      const hj = pathToHj(ep.path, ep.method)
      const params = getInputSchema(ep)
      const paramKeys = params && (params as any).properties ? Object.keys((params as any).properties) : []
      const paramHint = paramKeys.length > 0 ? ` [${paramKeys.slice(0, 3).join(', ')}${paramKeys.length > 3 ? ', ...' : ''}]` : ''
      lines.push(`- \`${hj}${paramHint}\` - ${ep.summary}`)
    }
    lines.push('')
  }

  lines.push('## Tips')
  lines.push('')
  lines.push('1. `hj tree` first — ref IDs are the fastest way to target elements')
  lines.push('2. Selectors support `:text()` pseudo-selector: `hj click "button:text(Sign in)"`')
  lines.push('3. `:text(/regex/i)` for regex matching: `hj click "a:text(/sign\\s+up/i)"`')
  lines.push('4. `hj events` shows what happened — aggregated semantic events, not raw DOM')
  lines.push('5. `hj highlight 42 "Look here"` to show the user something')
  lines.push('6. `hj recording start` survives page navigations — record OAuth flows, multi-page checkouts')
  lines.push('7. `hj api` for the full API reference with all parameters')
  lines.push('')
  lines.push('## Test Runner')
  lines.push('')
  lines.push('```')
  lines.push('hj test-run tests/login.json       # Run a test')
  lines.push('hj test-validate tests/login.json   # Validate format')
  lines.push('hj test-suite tests/a.json tests/b.json  # Run multiple')
  lines.push('```')
  lines.push('')
  lines.push('Test steps: `navigate`, `click`, `type`, `check`, `key`, `wait`, `assert`, `eval`, `verify`')
  lines.push('')
  lines.push('The `type` action uses realistic per-character keystroke simulation by default.')
  lines.push('Add `"paste": true` for fast paste-style input (still framework-compatible).')
  lines.push('')
  lines.push('## Full API Reference')
  lines.push('')
  lines.push('Run `hj api` for complete endpoint docs with all parameters and examples.')

  return lines.join('\n')
}

writeFileSync('DOCS.md', generateDocsMd())

// 2. Embed static assets into TypeScript (after schema-derived files are generated)
await $`bun run scripts/embed-assets.ts`

// 3. Build browser component (IIFE for injection)
await $`bun build ./src/component.ts --outdir=dist --target=browser --format=iife`

// 4. Build server, client, and index for Bun runtime
await $`bun build ./src/server.ts ./src/client.ts ./src/index.ts --outdir=dist --target=bun`

// 5. Sync component to desktop app resources (single source of truth)
await $`cp dist/component.js apps/desktop/resources/component.js`.quiet().nothrow()

console.log('Build complete')
