<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Agent Terminal</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    /* Shared base colors */
    :root {
      --bg-base: #1a1a2e;
      --bg-dark: #0f0f1e;
      --bg-surface: #252540;
      --border: #2d2d4a;
    }
    
    /* Human terminal: blue accent */
    body.mode-human {
      --accent: #6366f1;
      --accent-light: #a5b4fc;
    }
    
    /* Agent terminal: green accent */
    body.mode-agent {
      --accent: #22c55e;
      --accent-light: #86efac;
    }
    
    body {
      font-family: 'SF Mono', 'Menlo', 'Consolas', monospace;
      background: var(--bg-base);
      color: #e2e8f0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      font-size: 13px;
      line-height: 1.5;
      border-top: 2px solid var(--accent);
    }

    #status-bar {
      background: var(--bg-dark, #0f0f1e);
      padding: 6px 12px;
      font-size: 12px;
      border-bottom: 1px solid var(--border, #2d2d4a);
      color: #94a3b8;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-height: 28px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #status-bar .status-item {
      background: var(--bg-surface, #252540);
      padding: 2px 8px;
      border-radius: 3px;
      color: var(--accent-light, #a5b4fc);
    }
    #status-bar .status-item.alert {
      color: #fbbf24;
    }
    #status-bar .status-item.error {
      color: #f87171;
    }
    #status-bar .connected {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent, #4ade80);
      display: inline-block;
    }
    #status-bar .disconnected {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #f87171;
      display: inline-block;
    }
    #shell-id {
      color: var(--accent, #6366f1);
      font-weight: bold;
    }

    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .msg {
      white-space: pre-wrap;
      word-break: break-word;
      padding: 2px 0;
    }
    .msg-system {
      color: #64748b;
      font-style: italic;
    }
    .msg-push {
      color: #a5b4fc;
    }
    .msg-push .tool-name {
      color: #6366f1;
      font-weight: bold;
    }
    .msg-command {
      color: #94a3b8;
    }
    .msg-command::before {
      content: '> ';
      color: #4ade80;
    }
    .msg-output {
      color: #e2e8f0;
      padding-left: 12px;
      border-left: 2px solid #2d2d4a;
    }
    .msg-error {
      color: #f87171;
    }
    .msg-dm {
      color: #34d399;
    }
    .msg-dm .from-name {
      font-weight: bold;
      color: #10b981;
    }

    /* Board view */
    .board {
      display: flex;
      gap: 8px;
      padding: 8px 0;
      overflow-x: auto;
      min-height: 80px;
    }
    .board-col {
      min-width: 140px;
      max-width: 200px;
      background: #252540;
      border-radius: 4px;
      padding: 8px;
      flex-shrink: 0;
    }
    .board-col-title {
      font-size: 10px;
      color: #6366f1;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
      font-weight: bold;
    }
    .board-item {
      font-size: 12px;
      padding: 4px 6px;
      background: #1a1a2e;
      border-radius: 3px;
      margin-bottom: 4px;
      cursor: pointer;
      border-left: 3px solid transparent;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .board-item:hover {
      background: #2d2d4a;
    }
    .board-item.claimed {
      border-left-color: #4ade80;
    }
    .board-item .item-id {
      color: #64748b;
      margin-right: 4px;
    }

    /* Tool call cards */
    .tool-card {
      background: #1e1e3a;
      border: 1px solid #3d3d5c;
      border-radius: 6px;
      margin: 4px 0;
      overflow: hidden;
    }
    .tool-card-header {
      padding: 6px 10px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #a5b4fc;
      font-size: 12px;
    }
    .tool-card-header:hover {
      background: #252540;
    }
    .tool-card-header .tool-name {
      font-weight: bold;
    }
    .tool-card-header .tool-chevron {
      transition: transform 0.15s;
      font-size: 10px;
      color: #64748b;
    }
    .tool-card.expanded .tool-chevron {
      transform: rotate(90deg);
    }
    .tool-card-body {
      display: block;
      padding: 8px 10px;
      border-top: 1px solid #3d3d5c;
      font-size: 11px;
      max-height: 5lh;  /* ~5 lines by default */
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-word;
      color: #94a3b8;
    }
    .tool-card.expanded .tool-card-body {
      max-height: min(80vh, 600px);
    }
    .tool-card-body:empty {
      display: none;
    }
    .tool-card-label {
      color: #64748b;
      font-size: 10px;
      text-transform: uppercase;
      margin-bottom: 2px;
    }

    /* Agent prompt (user message in agent mode) */
    .msg-prompt {
      color: #e2e8f0;
      background: var(--bg-surface, #252540);
      padding: 6px 10px;
      border-radius: 6px;
      border-left: 3px solid var(--accent, #6366f1);
    }

    /* Agent thinking indicator */
    .thinking-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
      color: #64748b;
      font-size: 12px;
      padding: 4px 0;
    }
    .thinking-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent, #6366f1);
      animation: thinking-pulse 1.2s ease-in-out infinite;
    }
    @keyframes thinking-pulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }

    /* Agent cost/duration summary */
    .msg-summary {
      color: #64748b;
      font-size: 11px;
      padding: 2px 0;
      border-top: 1px solid #2d2d4a;
      margin-top: 4px;
    }

    #input-area {
      display: flex;
      padding: 8px 12px;
      border-top: 1px solid var(--border, #2d2d4a);
      background: var(--bg-dark, #0f0f1e);
      gap: 8px;
    }
    #input {
      flex: 1;
      background: var(--bg-surface, #252540);
      border: 1px solid var(--border, #2d2d4a);
      color: #e2e8f0;
      padding: 8px 10px;
      font-family: inherit;
      font-size: 13px;
      border-radius: 4px;
      outline: none;
      resize: vertical;
      min-height: 60px;
      max-height: 200px;
      overflow-y: auto;
      line-height: 1.5;
      field-sizing: content;
    }
    #input:focus {
      border-color: var(--accent, #6366f1);
    }
    #input::placeholder {
      color: #475569;
    }
    #stop-btn {
      display: none;
      background: #dc2626;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      font-family: inherit;
      font-size: 13px;
      cursor: pointer;
      white-space: nowrap;
    }
    #stop-btn:hover {
      background: #b91c1c;
    }
    #stop-btn.visible {
      display: block;
    }
  </style>
</head>
<body>
  <div id="status-bar">
    <span class="disconnected" id="conn-indicator"></span>
    <span id="shell-id"></span>
    <span id="status-text">connecting...</span>
  </div>
  <div id="messages">
    <div class="msg msg-system" id="welcome-msg"></div>
  </div>
  <div id="input-area">
    <textarea id="input" rows="1" placeholder="tool command..." autofocus></textarea>
    <button id="stop-btn">Stop</button>
  </div>

  <script>
    const params = new URLSearchParams(window.location.search)
    const PORT = params.get('port') || '8700'
    const MODE = params.get('mode') || 'human'
    const INITIAL_CWD = params.get('cwd') || ''
    const BASE_URL = `http://localhost:${PORT}`
    const WS_URL = `ws://localhost:${PORT}/ws/terminal`

    const messagesEl = document.getElementById('messages')
    const inputEl = document.getElementById('input')
    const statusTextEl = document.getElementById('status-text')
    const connIndicator = document.getElementById('conn-indicator')
    const shellIdEl = document.getElementById('shell-id')
    const stopBtn = document.getElementById('stop-btn')
    let ws = null
    let shellId = null
    let commandHistory = []
    let historyIndex = -1
    let isAgentThinking = false
    let pendingPrompt = null  // Message to send when agent finishes

    // ==========================================
    // WebSocket Connection
    // ==========================================

    function connect() {
      ws = new WebSocket(WS_URL)

      ws.onopen = () => {
        connIndicator.className = 'connected'
        if (!shellId) statusTextEl.textContent = 'connected'
      }

      ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data)
          switch (msg.type) {
            case 'identity':
              shellId = msg.shellId
              shellIdEl.textContent = shellId
              // Set initial cwd if provided via URL param
              if (INITIAL_CWD) {
                fetch(`${BASE_URL}/terminal/command`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ command: `cd ${INITIAL_CWD}`, shellId }),
                })
              }
              // Notify parent of initial cwd
              const initialCwd = INITIAL_CWD || msg.cwd
              if (initialCwd) {
                window.parent.postMessage({ type: 'terminal-cwd', cwd: initialCwd, shellId }, '*')
              }
              // Auto-name based on mode
              if (MODE === 'agent') {
                fetch(`${BASE_URL}/terminal/command`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ command: `whoami agent`, shellId }),
                })
              }
              break
            case 'cwd-changed':
              // Notify parent of cwd change
              window.parent.postMessage({ type: 'terminal-cwd', cwd: msg.cwd, shellId }, '*')
              break
            case 'status':
              renderStatusLine(msg.line)
              break
            case 'push':
              addMessage('push', `${msg.tool}: ${msg.text}`, msg.tool)
              scrollToBottom()
              break
            case 'message':
              addMessage('dm', `${msg.from}: ${msg.text}`, msg.from)
              scrollToBottom()
              break
            case 'shell-joined':
              if (msg.shellId !== shellId) {
                addMessage('system', `${msg.shellId} joined`)
                scrollToBottom()
              }
              break
            case 'shell-left':
              addMessage('system', `${msg.name || msg.shellId} left`)
              scrollToBottom()
              break
            case 'shell-renamed':
              if (msg.shellId === shellId) {
                shellIdEl.textContent = msg.name || shellId
                // Notify parent so it can update tab title (for agent tabs)
                window.parent.postMessage({ type: 'shell-renamed', shellId, name: msg.name }, '*')
              }
              addMessage('system', `${msg.shellId} → ${msg.name}`)
              scrollToBottom()
              break
            case 'task-changed':
              addMessage('system', `tasks updated by ${msg.by}`)
              scrollToBottom()
              break
            case 'agent-text':
              if (msg.shellId === shellId) {
                hideThinking()
                addMessage('output', msg.text)
                scrollToBottom()
              }
              break
            case 'agent-tool':
              if (msg.shellId === shellId) {
                hideThinking()
                renderToolCard(msg.tool, msg.input, msg.id)
              }
              break
            case 'agent-tool-result':
              if (msg.shellId === shellId) {
                addToolResult(msg.id, msg.output)
                scrollToBottom()
              }
              break
            case 'agent-done':
              if (msg.shellId === shellId) {
                hideThinking()
                setAgentThinking(false)
                if (msg.cost || msg.duration) {
                  const parts = []
                  if (msg.duration) parts.push(`${(msg.duration / 1000).toFixed(1)}s`)
                  if (msg.cost) parts.push(`$${msg.cost.toFixed(4)}`)
                  addMessage('summary', parts.join(' | '))
                }
                scrollToBottom()
                // Send pending prompt if any
                if (pendingPrompt) {
                  const prompt = pendingPrompt
                  pendingPrompt = null
                  sendAgentPrompt(prompt)
                }
              }
              break
            case 'agent-error':
              if (msg.shellId === shellId) {
                hideThinking()
                setAgentThinking(false)
                setAgentError()
                addMessage('error', msg.error)
                scrollToBottom()
                // Send pending prompt if any
                if (pendingPrompt) {
                  const prompt = pendingPrompt
                  pendingPrompt = null
                  sendAgentPrompt(prompt)
                }
              }
              break
            case 'agent-status':
              if (msg.shellId === shellId) {
                if (msg.status === 'thinking') {
                  showThinking()
                  setAgentThinking(true)
                } else {
                  hideThinking()
                  setAgentThinking(false)
                }
              }
              break
          }
        } catch {}
      }

      ws.onclose = () => {
        connIndicator.className = 'disconnected'
        statusTextEl.textContent = 'disconnected'
        setTimeout(connect, 2000)
      }

      ws.onerror = () => {
        ws.close()
      }
    }

    // ==========================================
    // Status Line Rendering
    // ==========================================

    function renderStatusLine(line) {
      if (!line) {
        statusTextEl.textContent = 'idle'
        return
      }
      const items = line.match(/\[([^\]]+)\]/g) || []
      let html = ''
      for (const item of items) {
        const text = item.slice(1, -1)
        let cls = 'status-item'
        if (/fail|error/i.test(text)) cls += ' error'
        else if (/warn|blocked/i.test(text)) cls += ' alert'
        html += `<span class="${cls}">${escapeHtml(text)}</span> `
      }
      statusTextEl.innerHTML = html || 'idle'
    }

    // ==========================================
    // Board View Rendering
    // ==========================================

    function renderBoard(boardData) {
      const container = document.createElement('div')
      container.className = 'board'

      const columnOrder = ['icebox', 'queued', 'in_progress', 'blocked', 'review', 'done']
      for (const col of columnOrder) {
        const items = boardData.columns[col]
        if (!items || items.length === 0) continue

        const colEl = document.createElement('div')
        colEl.className = 'board-col'

        const titleEl = document.createElement('div')
        titleEl.className = 'board-col-title'
        titleEl.textContent = col.replace('_', ' ')
        colEl.appendChild(titleEl)

        for (const item of items) {
          const itemEl = document.createElement('div')
          itemEl.className = 'board-item' + (item.claimed ? ' claimed' : '')
          itemEl.innerHTML = `<span class="item-id">#${item.id}</span>${escapeHtml(item.title)}`
          itemEl.title = item.claimed ? `claimed: ${item.claimed}` : item.title
          itemEl.addEventListener('click', () => {
            inputEl.value = `tasks detail ${item.id}`
            inputEl.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter' }))
          })
          colEl.appendChild(itemEl)
        }

        container.appendChild(colEl)
      }

      return container
    }

    // ==========================================
    // Command Input
    // ==========================================

    inputEl.addEventListener('keydown', async (e) => {
      // Human terminal: Enter sends, Shift+Enter inserts newline
      // Agent terminal: 
      //   - Shift+Enter or Cmd+Enter always sends
      //   - Enter at end of text, on empty line, with content above = submit
      //   - Otherwise Enter inserts newline (even on blank lines in middle)
      let isSubmit = false
      
      if (e.key === 'Enter') {
        if (MODE === 'agent') {
          if (e.shiftKey || e.metaKey) {
            // Explicit submit
            isSubmit = true
          } else {
            const text = inputEl.value
            const cursorPos = inputEl.selectionStart
            
            // Only consider submit if cursor is at the very end
            if (cursorPos === text.length && text.trim() !== '') {
              const lines = text.split('\n')
              const lastLine = lines[lines.length - 1]
              
              // Submit if last line is empty/whitespace and there's real content
              if (lastLine.trim() === '') {
                isSubmit = true
              }
            }
            // Otherwise, default behavior inserts newline
          }
        } else {
          // Human mode: Enter sends unless Shift held
          isSubmit = !e.shiftKey
        }
      }

      if (isSubmit && inputEl.value.trim()) {
        e.preventDefault()
        const command = inputEl.value.trim()
        commandHistory.push(command)
        historyIndex = commandHistory.length
        inputEl.value = ''

        if (MODE === 'agent') {
          await sendAgentPrompt(command)
        } else {
          await sendCommand(command)
        }
        return
      }

      // ArrowUp/Down for history (only when on first/last line)
      if (e.key === 'ArrowUp') {
        const cursorLine = inputEl.value.substring(0, inputEl.selectionStart).split('\n').length
        if (cursorLine === 1 && historyIndex > 0) {
          e.preventDefault()
          historyIndex--
          inputEl.value = commandHistory[historyIndex]
        }
      }
      if (e.key === 'ArrowDown') {
        const lines = inputEl.value.split('\n')
        const cursorLine = inputEl.value.substring(0, inputEl.selectionStart).split('\n').length
        if (cursorLine === lines.length) {
          e.preventDefault()
          if (historyIndex < commandHistory.length - 1) {
            historyIndex++
            inputEl.value = commandHistory[historyIndex]
          } else {
            historyIndex = commandHistory.length
            inputEl.value = ''
          }
        }
      }
    })

    async function sendCommand(command) {
      addMessage('command', command)
      scrollToBottom()

      try {
        const resp = await fetch(`${BASE_URL}/terminal/command`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ command, shellId }),
        })
        let output = await resp.text()

        // Extract and display status footer if present
        // Format: "...\n---\n[tests idle] [hj localhost] [todos empty] shellname"
        const footerMatch = output.match(/\n---\n(.+)$/)
        if (footerMatch) {
          output = output.slice(0, footerMatch.index)
          const footerLine = footerMatch[1]
          // Extract bracketed items for status bar
          const statusParts = footerLine.match(/\[[^\]]+\]/g)
          if (statusParts) {
            renderStatusLine(statusParts.join(' '))
          }
        }

        // Check if output is a board JSON
        if (output.startsWith('{"type":"board"')) {
          try {
            const boardData = JSON.parse(output)
            const boardEl = renderBoard(boardData)
            messagesEl.appendChild(boardEl)
          } catch {
            addMessage('output', output)
          }
        } else if (output.startsWith('error:')) {
          addMessage('error', output)
        } else {
          addMessage('output', output)
        }
      } catch (err) {
        addMessage('error', `connection error: ${err.message}`)
      }
      scrollToBottom()
    }

    // ==========================================
    // Agent Mode
    // ==========================================

    let thinkingEl = null

    function setAgentThinking(thinking) {
      isAgentThinking = thinking
      if (thinking) {
        stopBtn.classList.add('visible')
      } else {
        stopBtn.classList.remove('visible')
      }
      // Notify parent for tab status indicator
      window.parent.postMessage({ type: 'agent-status', status: thinking ? 'thinking' : 'ready' }, '*')
    }
    
    function setAgentError() {
      window.parent.postMessage({ type: 'agent-status', status: 'error' }, '*')
    }

    // Stop button handler
    stopBtn.addEventListener('click', async () => {
      try {
        await fetch(`${BASE_URL}/terminal/agent-stop`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ shellId }),
        })
      } catch (err) {
        addMessage('error', `stop failed: ${err.message}`)
      }
    })

    async function sendAgentPrompt(prompt) {
      // If agent is busy, queue this prompt for later
      if (isAgentThinking) {
        pendingPrompt = prompt
        addMessage('system', '(queued, will send when current task finishes)')
        return
      }

      // Show user prompt
      addMessage('prompt', prompt)
      showThinking()
      setAgentThinking(true)
      scrollToBottom()

      try {
        const resp = await fetch(`${BASE_URL}/terminal/agent-prompt`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt, shellId }),
        })
        if (!resp.ok) {
          const errText = await resp.text()
          hideThinking()
          setAgentThinking(false)
          addMessage('error', errText || `HTTP ${resp.status}`)
        }
        // Response is just acknowledgment — actual output comes via WebSocket
      } catch (err) {
        hideThinking()
        setAgentThinking(false)
        addMessage('error', `connection error: ${err.message}`)
      }
      scrollToBottom()
    }

    function showThinking() {
      hideThinking()
      thinkingEl = document.createElement('div')
      thinkingEl.className = 'thinking-indicator'
      thinkingEl.innerHTML = '<span class="thinking-dot"></span> thinking...'
      messagesEl.appendChild(thinkingEl)
      scrollToBottom()
    }

    function hideThinking() {
      if (thinkingEl && thinkingEl.parentNode) {
        thinkingEl.parentNode.removeChild(thinkingEl)
      }
      thinkingEl = null
    }

    // Track pending tool calls for matching results
    const pendingTools = new Map() // id → card element

    function renderToolCard(tool, input, id) {
      const card = document.createElement('div')
      card.className = 'tool-card'
      card.dataset.toolId = id

      const header = document.createElement('div')
      header.className = 'tool-card-header'
      header.innerHTML = `<span><span class="tool-name">${escapeHtml(tool)}</span> ${escapeHtml(summarizeInput(tool, input))}</span><span class="tool-chevron">▶</span>`
      header.addEventListener('click', () => {
        card.classList.toggle('expanded')
      })

      const body = document.createElement('div')
      body.className = 'tool-card-body'
      const inputLabel = document.createElement('div')
      inputLabel.className = 'tool-card-label'
      inputLabel.textContent = 'input'
      body.appendChild(inputLabel)
      const inputPre = document.createElement('pre')
      inputPre.style.cssText = 'margin: 0 0 6px 0; white-space: pre-wrap;'
      inputPre.textContent = input
      body.appendChild(inputPre)

      card.appendChild(header)
      card.appendChild(body)

      messagesEl.appendChild(card)
      pendingTools.set(id, card)
      scrollToBottom()
    }

    function addToolResult(id, output) {
      const card = pendingTools.get(id)
      if (card) {
        const body = card.querySelector('.tool-card-body')
        const outputLabel = document.createElement('div')
        outputLabel.className = 'tool-card-label'
        outputLabel.textContent = 'output'
        body.appendChild(outputLabel)
        const outputPre = document.createElement('pre')
        outputPre.style.cssText = 'margin: 0; white-space: pre-wrap;'
        // Truncate long outputs
        const lines = output.split('\n')
        if (lines.length > 20) {
          outputPre.textContent = lines.slice(0, 20).join('\n') + `\n... (${lines.length} lines total)`
        } else {
          outputPre.textContent = output
        }
        body.appendChild(outputPre)
        pendingTools.delete(id)
      }
    }

    function summarizeInput(tool, input) {
      // Show a short summary based on tool type
      try {
        const parsed = JSON.parse(input)
        if (parsed.file_path) return parsed.file_path
        if (parsed.command) return parsed.command.slice(0, 60)
        if (parsed.pattern) return parsed.pattern
        if (parsed.selector) return parsed.selector
        if (parsed.query) return parsed.query
      } catch {}
      // Fallback: first line, truncated
      const first = input.split('\n')[0]
      return first.length > 50 ? first.slice(0, 50) + '...' : first
    }

    // ==========================================
    // Message Display
    // ==========================================

    function addMessage(type, text, extra) {
      const div = document.createElement('div')
      div.className = `msg msg-${type}`
      if (type === 'push' && extra) {
        div.innerHTML = `<span class="tool-name">${escapeHtml(extra)}</span> ${escapeHtml(text.replace(extra + ': ', ''))}`
      } else if (type === 'dm' && extra) {
        div.innerHTML = `<span class="from-name">@${escapeHtml(extra)}</span> ${escapeHtml(text.replace(extra + ': ', ''))}`
      } else if (type === 'prompt') {
        div.textContent = text
      } else if (type === 'summary') {
        div.textContent = text
      } else {
        div.textContent = text
      }
      messagesEl.appendChild(div)

      while (messagesEl.children.length > 500) {
        messagesEl.removeChild(messagesEl.firstChild)
      }
    }

    function scrollToBottom() {
      messagesEl.scrollTop = messagesEl.scrollHeight
    }

    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
    }

    // ==========================================
    // Init
    // ==========================================

    // Apply mode-specific styling
    document.body.classList.add(`mode-${MODE}`)

    // Set welcome message and placeholder based on mode
    const welcomeEl = document.getElementById('welcome-msg')
    if (MODE === 'agent') {
      welcomeEl.textContent = 'Agent shell. Ask anything — Claude will respond with full tool access. Shift+Enter to send.'
      document.title = 'Agent Shell'
      inputEl.placeholder = 'Ask Claude... (Shift+Enter to send)'
    } else {
      welcomeEl.textContent = 'Terminal ready. Type "tasks" for the board, "who" for shells, or a tool command.'
      document.title = 'Terminal'
    }

    // Listen for messages from parent (address bar, restore, etc.)
    window.addEventListener('message', (event) => {
      if (event.data?.type === 'rename' && event.data.name && shellId) {
        fetch(`${BASE_URL}/terminal/command`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ command: `whoami ${event.data.name}`, shellId }),
        }).then(() => {
          shellIdEl.textContent = event.data.name
        })
      }
      
      // Load a restored transcript
      if (event.data?.type === 'load-transcript' && event.data.shellId) {
        loadRestoredTranscript(event.data.shellId)
      }
    })
    
    // Load and display a restored transcript from the server
    async function loadRestoredTranscript(targetShellId) {
      try {
        const response = await fetch(`${BASE_URL}/terminal/agent-transcript?shellId=${targetShellId}`)
        if (!response.ok) return
        
        const { transcript } = await response.json()
        if (!transcript || transcript.length === 0) return
        
        // Clear existing messages
        messagesEl.innerHTML = ''
        
        // Add a system message indicating this is a restored session
        addMessage('system', '--- Restored session ---')
        
        // Render each transcript entry
        for (const entry of transcript) {
          switch (entry.type) {
            case 'user':
              addMessage('prompt', entry.content)
              break
            case 'assistant':
              addMessage('output', entry.content)
              break
            case 'tool_call':
              // Create a tool card
              const toolCard = document.createElement('div')
              toolCard.className = 'tool-card'
              toolCard.innerHTML = `
                <div class="tool-header">
                  <span class="tool-name">${entry.toolName || 'tool'}</span>
                  <span class="tool-status">completed</span>
                </div>
                <div class="tool-body">
                  <div class="tool-input">
                    <span class="tool-label">Input:</span>
                    <pre>${escapeHtml(entry.toolInput || '').slice(0, 500)}</pre>
                  </div>
                </div>
              `
              toolCard.dataset.toolId = entry.toolId
              messagesEl.appendChild(toolCard)
              break
            case 'tool_result':
              // Find matching tool card and add output
              const card = messagesEl.querySelector(`.tool-card[data-tool-id="${entry.toolId}"]`)
              if (card) {
                const body = card.querySelector('.tool-body')
                const output = document.createElement('div')
                output.className = 'tool-output'
                output.innerHTML = `
                  <span class="tool-label">Output:</span>
                  <pre>${escapeHtml(entry.toolOutput || '').slice(0, 2000)}</pre>
                `
                body.appendChild(output)
              }
              break
            case 'system':
              addMessage('system', entry.content)
              break
          }
        }
        
        // Scroll to bottom
        messagesEl.scrollTop = messagesEl.scrollHeight
        
        addMessage('system', '--- End of restored session ---')
      } catch (err) {
        addMessage('error', `Failed to load transcript: ${err.message}`)
      }
    }
    
    // Helper to escape HTML
    function escapeHtml(text) {
      const div = document.createElement('div')
      div.textContent = text
      return div.innerHTML
    }

    fetch(`${BASE_URL}/terminal/status`)
      .then(r => r.text())
      .then(line => renderStatusLine(line))
      .catch(() => {})

    connect()
  </script>
</body>
</html>
