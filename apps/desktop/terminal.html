<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Agent Terminal</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    /* Shared base colors */
    :root {
      --bg-base: #1a1a2e;
      --bg-dark: #0f0f1e;
      --bg-surface: #252540;
      --border: #2d2d4a;
    }
    
    /* Human terminal: blue accent */
    body.mode-human {
      --accent: #6366f1;
      --accent-light: #a5b4fc;
    }
    
    /* Agent terminal: green accent */
    body.mode-agent {
      --accent: #22c55e;
      --accent-light: #86efac;
    }
    
    body {
      font-family: 'SF Mono', 'Menlo', 'Consolas', monospace;
      background: var(--bg-base);
      color: #e2e8f0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      font-size: 13px;
      line-height: 1.5;
      border-top: 2px solid var(--accent);
    }

    #status-bar {
      background: var(--bg-dark, #0f0f1e);
      padding: 6px 12px;
      font-size: 12px;
      border-bottom: 1px solid var(--border, #2d2d4a);
      color: #94a3b8;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      min-height: 28px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #status-bar .status-item {
      background: var(--bg-surface, #252540);
      padding: 2px 8px;
      border-radius: 3px;
      color: var(--accent-light, #a5b4fc);
    }
    #status-bar .status-item.alert {
      color: #fbbf24;
    }
    #status-bar .status-item.error {
      color: #f87171;
    }
    #status-bar .connected {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent, #4ade80);
      display: inline-block;
    }
    #status-bar .disconnected {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #f87171;
      display: inline-block;
    }
    #shell-id {
      color: var(--accent, #6366f1);
      font-weight: bold;
    }

    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .msg {
      white-space: pre-wrap;
      word-break: break-word;
      padding: 2px 0;
      flex-shrink: 0;
    }
    .msg-system {
      color: #64748b;
      font-style: italic;
    }
    .msg-push {
      color: #a5b4fc;
    }
    .msg-push .tool-name {
      color: #6366f1;
      font-weight: bold;
    }
    .msg-command {
      color: #94a3b8;
    }
    .msg-command::before {
      content: '> ';
      color: #4ade80;
    }
    .msg-output {
      color: #e2e8f0;
      padding-left: 12px;
      border-left: 2px solid #2d2d4a;
    }
    .msg-error {
      color: #f87171;
    }
    .msg-dm {
      color: #34d399;
    }
    .msg-dm .from-name {
      font-weight: bold;
      color: #10b981;
    }

    /* Board view */
    .board {
      display: flex;
      gap: 8px;
      padding: 8px 0;
      overflow-x: auto;
      min-height: 80px;
    }
    .board-col {
      min-width: 140px;
      max-width: 200px;
      background: #252540;
      border-radius: 4px;
      padding: 8px;
      flex-shrink: 0;
    }
    .board-col-title {
      font-size: 10px;
      color: #6366f1;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
      font-weight: bold;
    }
    .board-item {
      font-size: 12px;
      padding: 4px 6px;
      background: #1a1a2e;
      border-radius: 3px;
      margin-bottom: 4px;
      cursor: pointer;
      border-left: 3px solid transparent;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .board-item:hover {
      background: #2d2d4a;
    }
    .board-item.claimed {
      border-left-color: #4ade80;
    }
    .board-item .item-id {
      color: #64748b;
      margin-right: 4px;
    }

    /* Tool call cards */
    .tool-card {
      background: #1e1e3a;
      border: 1px solid #3d3d5c;
      border-radius: 6px;
      margin: 4px 0;
      overflow: hidden;
      flex-shrink: 0;
    }
    .tool-card-header {
      padding: 8px 10px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px;
      font-size: 12px;
      min-height: 32px;
    }
    .tool-card-header:hover {
      background: #252540;
    }
    .tool-card-header .tool-name {
      color: #64748b;
      font-size: 10px;
      text-transform: uppercase;
      white-space: nowrap;
      flex-shrink: 0;
    }
    .tool-card-header .tool-summary {
      color: #e2e8f0;
      font-family: ui-monospace, monospace;
      font-size: 12px;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
    }
    .tool-card-header .tool-chevron {
      font-weight: bold;
      color: #64748b;
      margin-right: 4px;
    }
    .tool-card.running .tool-chevron {
      color: var(--accent-light, #a5b4fc);
      animation: pulse-chevron 0.8s ease-in-out infinite;
    }
    @keyframes pulse-chevron {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    .tool-card-body {
      display: none;
      padding: 8px 10px;
      border-top: 1px solid #3d3d5c;
      font-size: 11px;
      max-height: min(40vh, 300px);
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-word;
      color: #94a3b8;
    }
    .tool-card.expanded .tool-card-body {
      display: block;
      max-height: min(80vh, 600px);
    }
    .tool-card-label {
      color: #64748b;
      font-size: 10px;
      text-transform: uppercase;
      margin-bottom: 2px;
    }
    .tool-card-output {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px dashed #3d3d5c;
    }
    /* Output preview - always visible */
    .tool-output-preview {
      padding: 6px 10px;
      font-size: 11px;
      color: #94a3b8;
      white-space: pre-wrap;
      word-break: break-word;
      border-top: 1px solid #3d3d5c;
      background: #1a1a2e;
    }



    /* Agent prompt (user message in agent mode) */
    .msg-prompt {
      color: #e2e8f0;
      background: var(--bg-surface, #252540);
      padding: 6px 10px;
      border-radius: 6px;
      border-left: 3px solid var(--accent, #6366f1);
    }

    /* Agent thinking indicator */
    .thinking-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
      color: #64748b;
      font-size: 12px;
      padding: 4px 0;
    }
    .thinking-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent, #6366f1);
      animation: thinking-pulse 1.2s ease-in-out infinite;
    }
    @keyframes thinking-pulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }

    /* Agent cost/duration summary */
    .msg-summary {
      color: #64748b;
      font-size: 11px;
      padding: 2px 0;
      border-top: 1px solid #2d2d4a;
      margin-top: 4px;
    }

    #input-area {
      display: flex;
      padding: 8px 12px;
      border-top: 1px solid var(--border, #2d2d4a);
      background: var(--bg-dark, #0f0f1e);
      gap: 8px;
    }
    #input {
      flex: 1;
      background: var(--bg-surface, #252540);
      border: 1px solid var(--border, #2d2d4a);
      color: #e2e8f0;
      padding: 8px 10px;
      font-family: inherit;
      font-size: 13px;
      border-radius: 4px;
      outline: none;
      resize: vertical;
      min-height: 60px;
      max-height: 200px;
      overflow-y: auto;
      line-height: 1.5;
      field-sizing: content;
    }
    #input:focus {
      border-color: var(--accent, #6366f1);
    }
    #input::placeholder {
      color: #475569;
    }
    #stop-btn {
      display: none;
      background: #dc2626;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      font-family: inherit;
      font-size: 13px;
      cursor: pointer;
      white-space: nowrap;
    }
    #stop-btn:hover {
      background: #b91c1c;
    }
    #stop-btn.visible {
      display: block;
    }
    #copy-btn {
      background: var(--bg-surface);
      border: 1px solid var(--border);
      color: var(--accent-light, #a5b4fc);
      cursor: pointer;
      font-size: 12px;
      padding: 4px 10px;
      border-radius: 4px;
    }
    #copy-btn:hover {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }
  </style>
</head>
<body>
  <div id="status-bar">
    <span class="disconnected" id="conn-indicator"></span>
    <span id="shell-id"></span>
    <span id="status-text">connecting...</span>
    <span style="flex:1"></span>
    <button id="copy-btn" title="Copy transcript">Copy</button>
  </div>
  <div id="messages">
    <div class="msg msg-system" id="welcome-msg"></div>
  </div>
  <div id="input-area">
    <textarea id="input" rows="1" placeholder="tool command..." autofocus></textarea>
    <button id="stop-btn">Stop</button>
  </div>

  <script>
    const params = new URLSearchParams(window.location.search)
    const PORT = params.get('port') || '8700'
    const MODE = params.get('mode') || 'human'
    const INITIAL_CWD = params.get('cwd') || ''
    const BASE_URL = `http://localhost:${PORT}`
    const WS_URL = `ws://localhost:${PORT}/ws/terminal`

    const messagesEl = document.getElementById('messages')
    const inputEl = document.getElementById('input')
    const statusTextEl = document.getElementById('status-text')
    const connIndicator = document.getElementById('conn-indicator')
    const shellIdEl = document.getElementById('shell-id')
    const stopBtn = document.getElementById('stop-btn')
    const copyBtn = document.getElementById('copy-btn')
    let ws = null
    let shellId = null
    let commandHistory = []
    let historyIndex = -1
    let isAgentThinking = false

    // ==========================================
    // WebSocket Connection
    // ==========================================

    function connect() {
      ws = new WebSocket(WS_URL)

      ws.onopen = () => {
        connIndicator.className = 'connected'
        if (!shellId) statusTextEl.textContent = 'connected'
      }

      ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data)
          switch (msg.type) {
            case 'identity':
              shellId = msg.shellId
              shellIdEl.textContent = shellId
              // Set initial cwd if provided via URL param
              if (INITIAL_CWD) {
                fetch(`${BASE_URL}/terminal/command`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ command: `cd ${INITIAL_CWD}`, shellId }),
                })
              }
              // Notify parent of initial cwd
              const initialCwd = INITIAL_CWD || msg.cwd
              if (initialCwd) {
                window.parent.postMessage({ type: 'terminal-cwd', cwd: initialCwd, shellId }, '*')
              }
              // Auto-name based on mode
              if (MODE === 'agent') {
                fetch(`${BASE_URL}/terminal/command`, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ command: `whoami agent`, shellId }),
                })
              }
              break
            case 'cwd-changed':
              // Notify parent of cwd change
              window.parent.postMessage({ type: 'terminal-cwd', cwd: msg.cwd, shellId }, '*')
              break
            case 'status':
              renderStatusLine(msg.line)
              break
            case 'push':
              addMessage('push', `${msg.tool}: ${msg.text}`, msg.tool)
              scrollToBottom()
              break
            case 'message':
              addMessage('dm', `${msg.from}: ${msg.text}`, msg.from)
              scrollToBottom()
              break
            case 'shell-joined':
              if (msg.shellId !== shellId) {
                addMessage('system', `${msg.shellId} joined`)
                scrollToBottom()
              }
              break
            case 'shell-left':
              addMessage('system', `${msg.name || msg.shellId} left`)
              scrollToBottom()
              break
            case 'shell-renamed':
              if (msg.shellId === shellId) {
                shellIdEl.textContent = msg.name || shellId
                // Notify parent so it can update tab title (for agent tabs)
                window.parent.postMessage({ type: 'shell-renamed', shellId, name: msg.name }, '*')
              }
              addMessage('system', `${msg.shellId} → ${msg.name}`)
              scrollToBottom()
              break
            case 'task-changed':
              addMessage('system', `tasks updated by ${msg.by}`)
              scrollToBottom()
              break
            case 'agent-text':
              if (msg.shellId === shellId) {
                hideThinking()
                // Skip empty or whitespace-only text
                if (msg.text?.trim()) {
                  // Sanitize and limit large outputs (especially HTML dumps)
                  let text = msg.text
                  // Detect HTML responses and collapse them
                  if (text.includes('<!doctype') || text.includes('<!DOCTYPE') || text.includes('<html')) {
                    text = '[HTML page received - likely an error response]\n' + text.slice(0, 200) + '...'
                  }
                  // Truncate very long outputs
                  else if (text.length > 5000) {
                    text = text.slice(0, 5000) + `\n... (truncated, ${text.length} chars total)`
                  }
                  addMessage('output', text)
                  scrollToBottom()
                }
              }
              break
            case 'agent-tool':
              if (msg.shellId === shellId) {
                hideThinking()
                renderToolCard(msg.tool, msg.input, msg.id)
              }
              break
            case 'agent-tool-result':
              console.log('[ws] agent-tool-result:', { id: msg.id, output: msg.output?.slice?.(0, 100) })
              if (msg.shellId === shellId) {
                addToolResult(msg.id, msg.output)
                scrollToBottom()
              }
              break
            case 'agent-done':
              if (msg.shellId === shellId) {
                hideThinking()
                setAgentThinking(false)
                if (msg.cost || msg.duration) {
                  const parts = []
                  if (msg.duration) parts.push(`${(msg.duration / 1000).toFixed(1)}s`)
                  if (msg.cost) parts.push(`$${msg.cost.toFixed(4)}`)
                  addMessage('summary', parts.join(' | '))
                }
                scrollToBottom()
              }
              break
            case 'agent-error':
              if (msg.shellId === shellId) {
                hideThinking()
                setAgentThinking(false)
                setAgentError()
                addMessage('error', msg.error)
                scrollToBottom()
              }
              break
            case 'agent-status':
              if (msg.shellId === shellId) {
                if (msg.status === 'thinking') {
                  showThinking()
                  setAgentThinking(true)
                } else {
                  hideThinking()
                  setAgentThinking(false)
                }
              }
              break
            case 'agent-message-queued':
              // Paste the message into the input field for user to review/edit/send
              if (msg.text && MODE === 'agent') {
                // Prefix with source info if from browser or other shell
                const prefix = msg.from && msg.from !== 'user' ? `[from ${msg.from}] ` : ''
                const fullText = prefix + msg.text
                
                // If input is empty, just set it; otherwise append with newline
                if (inputEl.value.trim()) {
                  inputEl.value = inputEl.value + '\n' + fullText
                } else {
                  inputEl.value = fullText
                }
                inputEl.focus()
                
                // If submit flag is set, auto-submit (CLI sends use this)
                if (msg.submit) {
                  addMessage('system', `Message from ${msg.from} submitted`)
                  // Use setTimeout to let the UI update first
                  setTimeout(() => {
                    sendInput()
                  }, 50)
                } else {
                  // Show a subtle notification for paste-only
                  addMessage('system', `Message from ${msg.from} pasted to input`)
                }
              } else {
                addMessage('system', `Message from ${msg.from} queued (${msg.count} pending)`)
              }
              scrollToBottom()
              break
            case 'agent-auto-resume':
              // Only auto-send if there's content in the input and agent is idle
              // This gives user a chance to review/edit the pasted message
              // Skip auto-resume - user will send when ready
              break
          }
        } catch {}
      }

      ws.onclose = () => {
        connIndicator.className = 'disconnected'
        statusTextEl.textContent = 'disconnected'
        setTimeout(connect, 2000)
      }

      ws.onerror = () => {
        ws.close()
      }
    }

    // ==========================================
    // Status Line Rendering
    // ==========================================

    function renderStatusLine(line) {
      if (!line) {
        statusTextEl.textContent = 'idle'
        return
      }
      const items = line.match(/\[([^\]]+)\]/g) || []
      let html = ''
      for (const item of items) {
        const text = item.slice(1, -1)
        let cls = 'status-item'
        if (/fail|error/i.test(text)) cls += ' error'
        else if (/warn|blocked/i.test(text)) cls += ' alert'
        html += `<span class="${cls}">${escapeHtml(text)}</span> `
      }
      statusTextEl.innerHTML = html || 'idle'
    }

    // ==========================================
    // Board View Rendering
    // ==========================================

    function renderBoard(boardData) {
      const container = document.createElement('div')
      container.className = 'board'

      const columnOrder = ['icebox', 'queued', 'in_progress', 'blocked', 'review', 'done']
      for (const col of columnOrder) {
        const items = boardData.columns[col]
        if (!items || items.length === 0) continue

        const colEl = document.createElement('div')
        colEl.className = 'board-col'

        const titleEl = document.createElement('div')
        titleEl.className = 'board-col-title'
        titleEl.textContent = col.replace('_', ' ')
        colEl.appendChild(titleEl)

        for (const item of items) {
          const itemEl = document.createElement('div')
          itemEl.className = 'board-item' + (item.claimed ? ' claimed' : '')
          itemEl.innerHTML = `<span class="item-id">#${item.id}</span>${escapeHtml(item.title)}`
          itemEl.title = item.claimed ? `claimed: ${item.claimed}` : item.title
          itemEl.addEventListener('click', () => {
            inputEl.value = `tasks detail ${item.id}`
            inputEl.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter' }))
          })
          colEl.appendChild(itemEl)
        }

        container.appendChild(colEl)
      }

      return container
    }

    // ==========================================
    // Command Input
    // ==========================================

    inputEl.addEventListener('keydown', async (e) => {
      // Simple and consistent: Enter sends, Shift+Enter inserts newline
      // Works the same in both human and agent modes
      
      if (e.key === 'Enter' && !e.shiftKey && inputEl.value.trim()) {
        e.preventDefault()
        const command = inputEl.value.trim()
        commandHistory.push(command)
        historyIndex = commandHistory.length
        inputEl.value = ''

        if (MODE === 'agent') {
          await sendAgentPrompt(command)
        } else {
          await sendCommand(command)
        }
        return
      }

      // ArrowUp/Down for history (only when on first/last line)
      if (e.key === 'ArrowUp') {
        const cursorLine = inputEl.value.substring(0, inputEl.selectionStart).split('\n').length
        if (cursorLine === 1 && historyIndex > 0) {
          e.preventDefault()
          historyIndex--
          inputEl.value = commandHistory[historyIndex]
        }
      }
      if (e.key === 'ArrowDown') {
        const lines = inputEl.value.split('\n')
        const cursorLine = inputEl.value.substring(0, inputEl.selectionStart).split('\n').length
        if (cursorLine === lines.length) {
          e.preventDefault()
          if (historyIndex < commandHistory.length - 1) {
            historyIndex++
            inputEl.value = commandHistory[historyIndex]
          } else {
            historyIndex = commandHistory.length
            inputEl.value = ''
          }
        }
      }
    })

    async function sendCommand(command) {
      addMessage('command', command)
      scrollToBottom()

      try {
        const resp = await fetch(`${BASE_URL}/terminal/command`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ command, shellId }),
        })
        let output = await resp.text()

        // Extract and display status footer if present
        // Format: "...\n---\n[tests idle] [hj localhost] [todos empty] shellname"
        const footerMatch = output.match(/\n---\n(.+)$/)
        if (footerMatch) {
          output = output.slice(0, footerMatch.index)
          const footerLine = footerMatch[1]
          // Extract bracketed items for status bar
          const statusParts = footerLine.match(/\[[^\]]+\]/g)
          if (statusParts) {
            renderStatusLine(statusParts.join(' '))
          }
        }

        // Check if output is a board JSON
        if (output.startsWith('{"type":"board"')) {
          try {
            const boardData = JSON.parse(output)
            const boardEl = renderBoard(boardData)
            messagesEl.appendChild(boardEl)
          } catch {
            addMessage('output', output)
          }
        } else if (output.startsWith('error:')) {
          addMessage('error', output)
        } else {
          addMessage('output', output)
        }
      } catch (err) {
        addMessage('error', `connection error: ${err.message}`)
      }
      scrollToBottom()
    }

    // ==========================================
    // Agent Mode
    // ==========================================

    let thinkingEl = null

    function setAgentThinking(thinking) {
      isAgentThinking = thinking
      if (thinking) {
        stopBtn.classList.add('visible')
      } else {
        stopBtn.classList.remove('visible')
      }
      // Notify parent for tab status indicator
      window.parent.postMessage({ type: 'agent-status', status: thinking ? 'thinking' : 'ready' }, '*')
    }
    
    function setAgentError() {
      window.parent.postMessage({ type: 'agent-status', status: 'error' }, '*')
    }

    // Stop button handler
    stopBtn.addEventListener('click', async () => {
      try {
        await fetch(`${BASE_URL}/terminal/agent-stop`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ shellId }),
        })
      } catch (err) {
        addMessage('error', `stop failed: ${err.message}`)
      }
    })

    // Copy transcript button handler
    copyBtn.addEventListener('click', () => {
      const text = extractConversationText()
      navigator.clipboard.writeText(text).then(() => {
        copyBtn.textContent = 'Copied'
        setTimeout(() => { copyBtn.textContent = 'Copy' }, 1500)
      }).catch(err => {
        addMessage('error', `copy failed: ${err.message}`)
      })
    })

    function extractConversationText() {
      const lines = []
      for (const msg of messagesEl.children) {
        if (msg.classList.contains('msg-system')) {
          // Include important system messages (queued, interrupted) but skip noise like "connected"
          const text = msg.textContent || ''
          if (text.includes('queued') || text.includes('interrupt') || text.includes('stopped')) {
            lines.push(`[${text}]`)
          }
          continue
        } else if (msg.classList.contains('msg-prompt')) {
          lines.push(msg.textContent)
        } else if (msg.classList.contains('msg-output')) {
          lines.push(msg.textContent)
        } else if (msg.classList.contains('msg-summary')) {
          lines.push(msg.textContent)
        } else if (msg.classList.contains('tool-card')) {
          const toolName = msg.querySelector('.tool-name')?.textContent || 'tool'
          const summary = msg.querySelector('.tool-summary')?.textContent || ''
          lines.push(`${toolName}\n${summary}\n▶`)
        }
      }
      return lines.join('\n')
    }

    async function sendAgentPrompt(prompt) {
      // Always show user prompt immediately
      addMessage('prompt', prompt)
      
      // If not already thinking, show thinking indicator
      if (!isAgentThinking) {
        showThinking()
        setAgentThinking(true)
      }
      scrollToBottom()

      try {
        const resp = await fetch(`${BASE_URL}/terminal/agent-prompt`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ prompt, shellId }),
        })
        if (!resp.ok) {
          const errText = await resp.text()
          hideThinking()
          setAgentThinking(false)
          addMessage('error', errText || `HTTP ${resp.status}`)
        }
        // Response is just acknowledgment — actual output comes via WebSocket
      } catch (err) {
        hideThinking()
        setAgentThinking(false)
        addMessage('error', `connection error: ${err.message}`)
      }
      scrollToBottom()
    }

    function showThinking() {
      hideThinking()
      thinkingEl = document.createElement('div')
      thinkingEl.className = 'thinking-indicator'
      thinkingEl.innerHTML = '<span class="thinking-dot"></span> thinking...'
      messagesEl.appendChild(thinkingEl)
      scrollToBottom()
    }

    function hideThinking() {
      if (thinkingEl && thinkingEl.parentNode) {
        thinkingEl.parentNode.removeChild(thinkingEl)
      }
      thinkingEl = null
    }

    // Track pending tool calls for matching results
    const pendingTools = new Map() // id → card element

    // Format tool name for display (handle MCP tools)
    function formatToolName(tool) {
      // MCP tools: mcp__acp__Read → Read (acp)
      if (tool.startsWith('mcp__')) {
        const parts = tool.split('__')
        const server = parts[1] || ''
        const name = parts[2] || tool
        return { name, server }
      }
      return { name: tool, server: '' }
    }

    function renderToolCard(tool, input, id) {
      try {
        // DEBUG: Log what we received
        console.log('[tool-card] render:', { tool, input: input?.slice?.(0, 100), id })
        
        const card = document.createElement('div')
        card.className = 'tool-card running'
        card.dataset.toolId = id || `unknown-${Date.now()}`

        const header = document.createElement('div')
        header.className = 'tool-card-header'
        
        // Handle missing data gracefully
        const toolName = tool || 'unknown'
        const toolInput = input || ''
        const toolId = id || 'no-id'
        
        const summary = summarizeInput(toolName, toolInput)
        const { name, server } = formatToolName(toolName)
        const serverTag = server ? ` <span style="opacity:0.5;font-size:10px">(${server})</span>` : ''
        
        // If no tool name, show debug info
        const displayName = toolName === 'unknown' ? `DEBUG: ${JSON.stringify({tool, id})}` : name
        
        header.innerHTML = `
          <span class="tool-name"><span class="tool-chevron">&gt;</span> ${escapeHtml(displayName)}${serverTag}</span>
          <span class="tool-summary">${escapeHtml(summary || '(no input)')}</span>
        `
        header.addEventListener('click', () => {
          card.classList.toggle('expanded')
        })

        const body = document.createElement('div')
        body.className = 'tool-card-body'
        const inputLabel = document.createElement('div')
        inputLabel.className = 'tool-card-label'
        inputLabel.textContent = 'input'
        body.appendChild(inputLabel)
        const inputPre = document.createElement('pre')
        inputPre.style.cssText = 'margin: 0; white-space: pre-wrap;'
        inputPre.textContent = toolInput
        body.appendChild(inputPre)

        card.appendChild(header)
        card.appendChild(body)

        messagesEl.appendChild(card)
        pendingTools.set(id, card)
        scrollToBottom()
      } catch (err) {
        console.error('[tool-card] render error:', err, { tool, input, id })
        addMessage('error', `Tool card error: ${err.message}`)
      }
    }

    function addToolResult(id, output) {
      console.log('[addToolResult]', { id, hasCard: pendingTools.has(id), output: output?.slice?.(0, 50) })
      const card = pendingTools.get(id)
      if (card) {
        card.classList.remove('running')
        
        // Show brief output preview directly visible (not hidden)
        const outputPreview = document.createElement('div')
        outputPreview.className = 'tool-output-preview'
        const lines = (output || '').split('\n')
        const previewText = lines.slice(0, 3).join('\n')
        outputPreview.textContent = previewText + (lines.length > 3 ? `\n... (${lines.length} lines)` : '')
        card.appendChild(outputPreview)
        
        // Add full output to expandable body
        const body = card.querySelector('.tool-card-body')
        const outputDiv = document.createElement('div')
        outputDiv.className = 'tool-card-output'
        const outputLabel = document.createElement('div')
        outputLabel.className = 'tool-card-label'
        outputLabel.textContent = 'output'
        outputDiv.appendChild(outputLabel)
        const outputPre = document.createElement('pre')
        outputPre.style.cssText = 'margin: 0; white-space: pre-wrap;'
        if (lines.length > 20) {
          outputPre.textContent = lines.slice(0, 20).join('\n') + `\n... (${lines.length} lines total)`
        } else {
          outputPre.textContent = output || ''
        }
        outputDiv.appendChild(outputPre)
        body.appendChild(outputDiv)
        pendingTools.delete(id)
      } else {
        console.warn('[addToolResult] No card found for id:', id, 'pending ids:', Array.from(pendingTools.keys()))
      }
    }

    function summarizeInput(tool, input) {
      // Show a short summary based on tool type
      if (!input || input.trim() === '') return '(no input)'
      
      try {
        const parsed = JSON.parse(input)
        // File operations
        if (parsed.file_path) return parsed.file_path
        // Bash commands
        if (parsed.command) return parsed.command.slice(0, 80)
        // Search operations
        if (parsed.pattern) return `"${parsed.pattern}"${parsed.path ? ` in ${parsed.path}` : ''}`
        // Browser operations
        if (parsed.selector) return parsed.selector
        if (parsed.url) return parsed.url.slice(0, 60)
        // Web search
        if (parsed.query) return parsed.query
        // Edit operations - show old_string snippet
        if (parsed.old_string) return `"${parsed.old_string.slice(0, 40)}..." → ...`
        // Write operations - show content preview
        if (parsed.content && typeof parsed.content === 'string') {
          return parsed.content.split('\n')[0].slice(0, 50) + '...'
        }
        // Task/Agent operations
        if (parsed.prompt) return parsed.prompt.slice(0, 60)
        if (parsed.description) return parsed.description.slice(0, 60)
        // Todos
        if (parsed.todos && Array.isArray(parsed.todos)) {
          return `${parsed.todos.length} item(s)`
        }
        // Generic: show first key-value
        const keys = Object.keys(parsed)
        if (keys.length > 0) {
          const firstKey = keys[0]
          const val = parsed[firstKey]
          if (typeof val === 'string') return `${firstKey}: ${val.slice(0, 40)}`
          if (typeof val === 'number' || typeof val === 'boolean') return `${firstKey}: ${val}`
        }
      } catch {}
      // Fallback: first line, truncated
      const first = (input || '').split('\n')[0]
      return first.length > 50 ? first.slice(0, 50) + '...' : (first || '(empty)')
    }

    // ==========================================
    // Message Display
    // ==========================================

    function addMessage(type, text, extra) {
      const div = document.createElement('div')
      div.className = `msg msg-${type}`
      if (type === 'push' && extra) {
        div.innerHTML = `<span class="tool-name">${escapeHtml(extra)}</span> ${escapeHtml(text.replace(extra + ': ', ''))}`
      } else if (type === 'dm' && extra) {
        div.innerHTML = `<span class="from-name">@${escapeHtml(extra)}</span> ${escapeHtml(text.replace(extra + ': ', ''))}`
      } else if (type === 'prompt') {
        div.textContent = text
      } else if (type === 'summary') {
        div.textContent = text
      } else {
        div.textContent = text
      }
      messagesEl.appendChild(div)

      while (messagesEl.children.length > 500) {
        messagesEl.removeChild(messagesEl.firstChild)
      }
    }

    function scrollToBottom() {
      messagesEl.scrollTop = messagesEl.scrollHeight
    }

    function escapeHtml(str) {
      if (str == null) return ''
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
    }

    // ==========================================
    // Init
    // ==========================================

    // Apply mode-specific styling
    document.body.classList.add(`mode-${MODE}`)

    // Set welcome message and placeholder based on mode
    const welcomeEl = document.getElementById('welcome-msg')
    if (MODE === 'agent') {
      welcomeEl.textContent = 'Agent shell. Ask anything — Claude will respond with full tool access. Shift+Enter to send.'
      document.title = 'Agent Shell'
      inputEl.placeholder = 'Ask Claude... (Shift+Enter to send)'
    } else {
      welcomeEl.textContent = 'Terminal ready. Type "tasks" for the board, "who" for shells, or a tool command.'
      document.title = 'Terminal'
    }

    // Listen for messages from parent (address bar, restore, etc.)
    window.addEventListener('message', (event) => {
      if (event.data?.type === 'rename' && event.data.name && shellId) {
        fetch(`${BASE_URL}/terminal/command`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ command: `whoami ${event.data.name}`, shellId }),
        }).then(() => {
          shellIdEl.textContent = event.data.name
        })
      }
      
    })

    fetch(`${BASE_URL}/terminal/status`)
      .then(r => r.text())
      .then(line => renderStatusLine(line))
      .catch(() => {})

    connect()
  </script>
</body>
</html>
